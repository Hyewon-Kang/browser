<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=
    , initial-scale=1.0">
    <title>requestAnimationFrame</title>
    <style>
        button {
            font-size: 60px;
        }

        button:hover {
            background-color: antiquewhite;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <button>RequestAnimationFrame</button>
    <script>
        const button = document.querySelector('button');
        button.addEventListener('click', () => {
            requestAnimationFrame(() => {
                document.body.style.backgroundColor = 'beige';
            });
            requestAnimationFrame(() => {
                document.body.style.backgroundColor = 'orange';
            });
            requestAnimationFrame(() => {
                document.body.style.backgroundColor = 'red';
            });
            setTimeout(() => {

            }, 0);
        });

        /*
            requestAnimationFrame: 웹 API 중 하나. 우리가 등록한 콜백 함수가 나중에 브라우저에서 다음 렌더링이 발생하기 전에 이 콜백이 수행되는 것을 보장해줌

            위의 코드에서는 queue는 FIFO이므로 최종적으로 적용되는 것은 배경 색이 빨간색으로 지정한 코드임. 빨간색 코드가 적용 된 상태에서 렌더 트리와 레이아웃이 만들어지고 페인트가 이뤄짐.

            클릭 리스너가 수행될 때는 코드를 변경하지 않고 나중에 브라우저가 화면을 업데이트 하기 전에 등록해놓은 변경 사항을 적용해 넣음.

            콜 스택 안에서 이 코드 블럭이 실행되는 순간 말고 코드 블럭이 끝나고 이벤트 루프가 한바퀴 돌 때 그 다음에 이 코드블럭을 실행해달라고 말하고 싶을 때 setTimeout 0를 많이 씀.
        */
    </script>
</body>

</html>