프로세스: 컴퓨터 위에서 즉, 운영체제 위에서 연속적으로 실행되고 있는 프로그램. 프로그래밍을 동작하는 최고 당누이.  ex) 음악 재생 프로그램, 사진 뷰어 프로그램 등
각각의 프로세스는 메모리 위에서 서로 "독립적"으로 실행됨. 
프로세스마다 할당된 메모리나 데이터들이 지정되어져있음. 

프로세스 안에는 코드, 스택, 힙, 데이터가 들어있음.
코드: 프로그램을 실행하기 위한 코드
스택: 코드와 프로세스 안에서 함수들이 어떤 순서로 실행되어야 하는지, 함수가 끝나면 어디로 다시 돌아가야 하는지에 대한 정보를 저장
힙: 오브젝트를 생성하거나 데이터를 만들 때 데이터들이 저장되는 공간
데이터: 전역 변수나 스태틱 변수들이 할당됨. 

쓰레드: 한 프로세스 안에서 여러개가 동작할 수 있음. 쓰레드는 저마다 해야하는 업무를 배정받음. 일꾼이라고도 불림. 프로그램 안에서 동시에 여러개가 수행될 수 있는 작은 일꾼 단위. 
쓰레드는 자기들만의 수행해야 하는 함수의 호출을 기억해야하기 때문에 스택이 할당됨. 하지만, 결국은 한 프로그램을 위해서 일해야하므로 프로세스에 지정된 코드와 데이터, 힙들을 공통적으로 접근해서 공통적으로 업데이트가 가능함. 쓰레드는 동시다발적으로 발생할 수 있기 때문에 프로세스가 조금 더 효율적으로 일을 할 수 있도록 도와줌. 
쓰레드는 자신들이 일을 수행할 때 어디에서부터 어디까지 일을 했고, 다음엔 어디로 가야하는지 일에 대한 흐름을 기억할 수 있는 고유의 스택이 지정되어져 있지만, 데이터, 코드, 힙 같은 공통 데이터 리소스는 프로세스에 있기 때문에 쓰레드들은 이 프로세스에 공통적으로 할당된 리스소에 동시다발적으로 접속해 업데이트 해야 돼서 공유하면서 사용함. 

자바는 언어 자체에서 멀티 쓰레딩이 지원됨. 
=> 프로그래밍을 짤 때, 사용자가 이 데이터를 보고 있는 동안 서버에서 데이터를 받아오는건 A 쓰레드에서 하고, 다른 일은 B 쓰레드에서 하는 것을 지정해서 프로그래밍을 짤 수 있음. 총 몇 개의 쓰레드가 동작할 수 있는지 등 다양한 것들을 할 수 있음. 


자바 스크립트는 싱글 쓰레드 언어임. 
=> 언어 자체에는 멀티 쓰레딩이 없음. 멀티 쓰레딩을 할 수 있는 방법은 없지만, 브라우저라는 프로그램 안에는 여러가지의 쓰레드가 들어있음. 즉, 웹 APIs를 이용하게되면 멀티 쓰레딩이 가능해짐. 
런타임 환경에서는 멀티 쓰레딩 뿐만 아니라 이벤트 루프를 이용해 조금 더 다양한 동작을 실행할 수 있음. 


메모리 힙(Memory Heap): 변수를 선언해서 오브젝트를 할당하거나, 문자열이나 숫자를 할당하게 되면 그 데이터들은 전부 다 메모리 힙에 저장이 됨.
메모리 힙은 구조적으로 정리된 자료구조가 아니라 자료들이 아무곳에나 저장되어져 있음. 

콜 스택(Call Stack): 우리가 함수를 실행하는 순서에 따라 차곡 차곡 쌓아놓는 스택. 

Stack? LIFO(Last In First Out) 
 push: 삽입 
 pop: 삭제

콜 스택의 동작 방법

function second() {
    console.log('hello');
    return;
}
function first() {
    second();
    return;
}
function main() {
    first();
    return;
}
main();
//

웹 APIs를 통해서 콜백 함수가 동작하는 방법
ex) setTimeOut

fucntion second() {
    setTimeOut(() => {
        console.log('hello');
    }, 3000);
}

second에서 setTimeOut을 호출하는 순간 setTimeOut은 콜백에서 지워지고, 웹 API는 타이머를 시작함. 타이머와 자바스크립트 엔진은 병렬적으로 실행되고 있다가, 지정된 시간이 끝나면 웹 APIs는 태스크 큐에 "타이머 끝났어! 여기 네가 등록한 콜백이야" 하며 콜백 자체를 태스크 큐에 집어넣음. 콜 스택이 텅 비워지면 이벤트 루프에 있는 아이를 콜 스택으로 데리고 옴. 그럼 자바스크립트 엔진이 콜 스택에 들어온 타임아웃 콜백을 실행함. 


Queue? FIFO (First In First Out)
Task Queue: 지정된 이벤트가 발생했을 때 태스크 큐에 넣음. 

이벤트 루프: 프로세스가 동작하는 동안 계속해서 루프를 돌면서 콜 스택이 비워졌다면 태스크 큐에 들어 있는 것들을 콜 스택으로 가져와 자바스크립트 엔진이 수행할 수 있도록 도와줌. 


=> 자바스크립트 코드에서 버튼에 클릭 리스너를 등록해 놓으면, 브라우저에서 버튼이 클릭 되면 웹 APIs는 이벤트 루프에 등록된 콜백 함수를 큐 안에다 넣음. 그리고 버튼에 클릭이 한번 더 일어나면 등록한 콜백 함수가 또 태스크 큐에 들어오게 됨. setTimeOut이 다 수행되면(=콜 스택이 비워지면) 이벤트 루프에 있는 클릭의 콜백 하나를 콜 스택에 가지고 옴. (태스크 큐에 있는 것들은 한번에 하나만 콜 스택으로 가져감) 


결론: 웹 APIs에서 setTimeOut, setInterval, addClickListener 같은 아이들을 쓸 때 지정한 콜백 함수를 등록해 놓은 뒤 이벤트가 발생하면 웹 APIs는 등록된 콜백 함수를 큐 안으로 넣게 됨. 이벤트 루프는 계속 돌면서 콜 스택이 비워져 있으면 태스크 큐에 있는 아이를 하나만 가지고 와서 콜 스택에 넣어줌. 이런 식으로 웹 APIs가 동작하게 됨. 


Microtask Queue: 프로미스에 등록한 then에 등록된 콜백 함수, mutation observer(웹 API 중 한 개)에 등록된 콜백이 들어옴

render: 주기적으로 브라우저에 업데이트 해 주는 것. ex) Request Animation Frame, Render Tree, Layout, Paint

Request Animation Frame: API. 이걸 통해서 콜백을 등록해 놓으면 다음에 브라우저가 업데이트 되기 전에 내 콜백을 실행해주는 API. 이 때 호출하는 콜백은 이 Request Animation Frame의 안에 들어있는 큐에 쌓임. 


이벤트 루프는 구현 상으로 보면 while(ture) 같은 아이를 이용해서 계속해서 도는 루프 중 하나. 평소에 계속해서 돌다가 콜 스택에서 수행중인 함수가 있으면 끝날 때까지 콜 스택에 머물러있음. 만약, 콜 스택에서 시간이 굉장히 오래 걸리는 것을 하게 되면 사용자에게 더이상 화면이 업데이트되어져 보이지 않음. 그리고 다른 클릭이 발생해도 클릭에 등록된 콜백 함수가 실행되지 않음. 왜? 이벤트 루프는 계속 콜 스택에 머물러 있기 때문에.

다음에는 렌더 쪽으로 갈 수도 있고, 안갈 수도 있음. 왜냐면 이벤트 루프는 한바퀴 도는데 1ms가 걸리는데 사용자의 눈에 부드럽게 애니메이션 된다는 느낌을 받게 하기 위해서는 1초당 60개의 프레임(= 60 fps(16.7 ms))을 보여줘야함. 그렇게 하기 위해서는 16.7ms 동안 업데이트가 일어나야 하기 때문에 계속해서 돌다가 시간이 되면 렌더를 업데이트 해줌. (브라우저마다 지정된 시간이 다름! 보통은 16.7ms)

다음으로 마이크로 태스크 큐에 아이템들이 있으면 큐 안에 있는 아이템들이 없어질 때까지 기다렸다가 하나씩 콜 스택으로 가지고 감. 포인트는 마이크로 태스크 큐에 또 다른 콜백이 들어온다면 나중에 들어온 콜백들도 전부 다 끝날 때까지 콜 스택으로 갖고 와서 수행함. 

다음으로 태스크 큐에서는 한 번에 딱 하나의 아이템만 콜 스택으로 가져옴. 마이크로 태스크 큐에서는 새로 들어오는 아이템이 전부 끝날때까지 기다린 반면, 태스크 큐에서는 아이템 하나만 콜 스택으로 보내놓고 콜 스택에서 이 콜백이 끝날때까지 기다림. 콜 스택에 있는 콜백 함수가 끝나고 나서야 다시 순회를 시작함. 

업데이트 할 시간이 되면 렌더 시퀀스에 들어가서 먼저 Request Animation Frame을 통해서 등록된 콜백 함수들을 천천히 하나 하나씩 다 실행한 다음에 Render Tree로 와서 트리를 만들고, 트리를 이용해서 레이아웃을 계산한 다음 페인트를 통해서 브라우저에 업데이트를 함. 